#pragma config(Sensor, S1,     etaluotain,     sensorEV3_IRSensor)
#pragma config(Sensor, S2,     variluotain,    sensorEV3_Color)
#pragma config(Sensor, S3,     kosketus,       sensorEV3_Touch)
#pragma config(Sensor, S4,     Gyroskooppi,    sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Motor,  motorA,          Mkippi,        tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          Ma,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          Mb,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// === Asetukset ===
int SYKLI = 50; // moottorien kayttoaika
int PEHMEYS = 10; // Kiihdytyksen ja hidastuksen lisays
int NOPEUS = 100; // Matkanopeus
int HIDASNOPEUS = 30; // Hitaampi nopeus
int TAVOITEVARI = 3; // Roskin vari
int KULMAMARGINAALI = 10; // Kuinka tarkkaan kaannytaan kulmaan
int INFRAETAISYYS = 20; // Kuinka voimakkasti infra palaa
int PERUUTUSPITUUS = 7; // kuinka monta syklia on peruutus
// Colours range from 0 to 7
// None    = 0
// Black   = 1
// Blue    = 2
// Green   = 3
// Yellow  = 4
// Red     = 5
// White   = 6
// Brown   = 7

// Globaalit muuttujat
int MUISTIPAIKKOJA = 20; // Montako etenemista tallennetaan
int syklit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
short kulmat[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int tallennusrivi = 0;

// Abstrakti funktio, jonka kautta kaikki moottorikomennot ajetaan
void liiku(int b, int c) {
	motor[Ma] = b * -1;
	motor[Mb] = c * -1;
	wait1Msec(SYKLI);
}

void kuljeEteen() {
	liiku(NOPEUS,NOPEUS);
}

void kuljeTaakse() {
	liiku(NOPEUS*-1,NOPEUS*-1);
}

void kuljeEteenHitaasti() {
	liiku(HIDASNOPEUS,HIDASNOPEUS);
}

void kuljeTaakseHitaasti() {
	liiku(HIDASNOPEUS*-1,HIDASNOPEUS*-1);
}

// Kiihdytetaan
void kiihdyta(int k1) {
	int i = 0;
  while (i <= NOPEUS) {
  	liiku(i*k1,i*k1);
		i += PEHMEYS;
	}
	return;
}

// Hidastetaan
void hidasta(int k1) {
	int i = NOPEUS;
  while (i >= 0) {
  	liiku(i*k1,i*k1);
		i -= PEHMEYS;
	}
	return;
}

void kiihdytaEteen() {
	liiku(0,0);
	kiihdyta(1);
}

void hidastaEteen() {
	hidasta(1);
	liiku(0,0);
}

void kiihdytaTaakse() {
	liiku(0,0);
	kiihdyta(-1);
}

void hidastaTaakse() {
	hidasta(-1);
	liiku(0,0);
}

void peruuta() {
	int i;
	for (i = 1; i <= PERUUTUSPITUUS; i++) {
		kuljeTaakse();
	}
}

void kaanny(short kulma) {
	
	drawBmpfile(0, 127, "Gyro sensor");

	while (true) {

		// Kaantyminen valmis
		if (SensorValue(Gyroskooppi) > kulma-KULMAMARGINAALI && SensorValue(Gyroskooppi) < kulma+KULMAMARGINAALI) {
			liiku(0,0);
			return;
		}

		// Kaaannytaan kohti tavoitekulmaa
		if (SensorValue(Gyroskooppi) > kulma) {
			liiku(HIDASNOPEUS,HIDASNOPEUS*-1);
		} else if (SensorValue(Gyroskooppi) < kulma) {
			liiku(HIDASNOPEUS*-1,HIDASNOPEUS);
		}

	}
}

void eteneSykli(short kulma) {

	// Eroa kaytetaan, kun paatetaan, kuinka jyrkasti korjataan
	int ero = abs(kulma - SensorValue(Gyroskooppi));

	// Jos gyro eroaa tavoitelinjasta
	if (SensorValue(Gyroskooppi) > kulma) {
		if (ero < 30) {
			// Jos ero on alle 30astetta, niin loiva kaannos
			liiku(NOPEUS,NOPEUS-30);
		} else {
			// Muuten jyrkka kaannos
			liiku(NOPEUS,NOPEUS/3);
		}
	} else if (SensorValue(Gyroskooppi) < kulma) {
		if (ero < 30) {
			liiku(NOPEUS-30,NOPEUS);
		} else {
			liiku(NOPEUS/3,NOPEUS);
		}
	} else {
		liiku(NOPEUS,NOPEUS);
	}

}

void etene(short kulma) {
	
	drawBmpfile(0, 127, "Forward");

	kulmat[tallennusrivi] = kulma;

	while (true) {

		// Jos edessa jotain, lopetetaan eteneminen
		if (getIRDistance(etaluotain) < INFRAETAISYYS) {
			tallennusrivi += 1;
			return;
		}

		eteneSykli(kulma);
		syklit[tallennusrivi] = syklit[tallennusrivi] + 1;

	}
}


void kaannyYmpari(short kulma) {
	
	wait1Msec(SYKLI*10);
	kaanny(kulma);
	wait1Msec(SYKLI*10);
}


void perilla() {
	
	drawBmpfile(0, 127, "Big smile");

	
	wait1Msec(2000);
	playSoundFile("Laser");
	
	motor[Mkippi] = -100;
	wait1Msec(500);
	motor[Mkippi] = 0;

	wait1Msec(2000);
	playSoundFile("Good job");
	
	motor[Mkippi] = 30;
	wait1Msec(500);
	motor[Mkippi] = 0;

	wait1Msec(2000);
}


int haistele() {
	
	drawBmpfile(0, 127, "Color sensor");

	int i, currentColour;
	int colours[8] = {0,0,0,0,0,0,0,0};
	int mostColor = 0;
	int mostColorAmount = 0;

	for (i = 0; i < 5; i++) {
		kuljeEteenHitaasti();
		currentColour = SensorValue[variluotain];
		if (currentColour <= 7) {
			colours[currentColour] = colours[currentColour] + 1;
		} else {
			colours[0] = colours[0] + 1;
		}
	}
	liiku(0,0);
	for (i = 5; i < 10; i++) {
		kuljeTaakseHitaasti();
		currentColour = SensorValue[variluotain];
		if (currentColour <= 7) {
			colours[currentColour] = colours[currentColour] + 1;
		} else {
			colours[0] = colours[0] + 1;
		}
	}
	liiku(0,0);

	for (i = 1; i <= 7; i++) {
		if (colours[i] > mostColorAmount) {
			mostColor = i;
			mostColorAmount = colours[i];
		}
	}

	return mostColor;
}


void palaaTakaisin() {

	int i, j, paluukulma;
	
	for (i = MUISTIPAIKKOJA-1; i >= 0; i--) {

		syklit[i] = syklit[i] - PERUUTUSPITUUS;
		if (syklit[i] <= 0) {
			continue;
		}

		drawBmpfile(0, 127, "Backward");
		paluukulma = kulmat[i] - 180;

		kaanny(paluukulma);
		kiihdytaEteen();

		for (j = 1; j <= syklit[i]; j++) {
			eteneSykli(paluukulma);
		}

		hidastaEteen();
	}
	
}


void mene(short kulma) {

	kaanny(kulma);
	kiihdytaEteen();
	etene(kulma);
	hidastaEteen();
	int mostColor = haistele();

	// TODO mita kun kohteessa?
	wait1Msec(2000);
	if (mostColor == TAVOITEVARI) {
		playSoundFile("Sonar");
		drawBmpfile(0, 127, "Accept");
		wait1Msec(2000);
	}

	kiihdytaTaakse();
	peruuta();
	hidastaTaakse();
}

void odotaKosketusta() {
	drawBmpfile(0, 127, "Neutral");
	while (true) {
		// Tarkistetaan, ettÃ¤ roska on laitettu kyytiin
		if (SensorValue[kosketus]) {
			return;
		}
		wait1Msec(SYKLI);
	}
}

task main()
{
	// Nollataan gyro robotin menosuunnan mukaiseksi
	setSensorMode(Gyroskooppi, modeEV3Gyro_Angle);
	resetGyro(Gyroskooppi);
	drawBmpfile(0, 127, "Hourglass 0");
	
	setSoundVolume(100);
	wait1Msec(2000);
	
	while (true) {
		odotaKosketusta();
		mene(0);
		mene(90);
		mene(0);
		kaannyYmpari(-180);
		perilla();
		palaaTakaisin();
		kaannyYmpari(0);
	}
}
