#pragma config(Sensor, S1,     etaluotain,     sensorEV3_IRSensor)
#pragma config(Sensor, S2,     variluotain,    sensorEV3_Color)
#pragma config(Sensor, S3,     kosketus,        sensorEV3_Touch)
#pragma config(Sensor, S4,     Gyroskooppi,           sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Motor,  motorA,          MotorA,        tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          MotorB,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          MotorC,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Nykyinen vari
short currentColour;

int subtask;
int maintask;
int nopeus;

// Abstrakti funktio, jonka kautta kaikki moottorikomennot ajetaan
void liiku(int b, int c) {
	motor[motorB] = b * -1;
	motor[motorC] = c * -1;
	wait1Msec(50);
	return;
}

void eteen(int i) {
	liiku(i,i);
	return;
}

void taakse(int i) {
	i = i * -1;
	liiku(i,i);
	return;
}

// Eteenpäin gyrolla kulmaa kohti
void eteenGyrolla(short kulma) {

	// Eroa kaytetaan, kun paatetaan, kuinka jyrkasti korjataan
	int ero = abs(kulma - SensorValue(Gyroskooppi));

	// Jos gyro eroaa tavoitelinjasta
	if (SensorValue(Gyroskooppi) > kulma) {
		if (ero < 30) {
			// Jos ero on alle 30astetta, niin loiva kaannos
			liiku(nopeus,nopeus-30);
		} else {
			// Muuten jyrkka kaannos
			liiku(nopeus,nopeus/3);
		}
	} else if (SensorValue(Gyroskooppi) < kulma) {
		if (ero < 30) {
			liiku(nopeus-30,nopeus);
		} else {
			liiku(nopeus/3,nopeus);
		}
	} else {
		eteen(nopeus);
	}
}

// Kaaannytaan kohti tavoitekulmaa
void kaannyGyrolla(short kulma) {
	if (SensorValue(Gyroskooppi) > kulma) {
		liiku(nopeus,nopeus*-1);
	} else if (SensorValue(Gyroskooppi) < kulma) {
		liiku(nopeus*-1,nopeus);
	}
}

// kippaa lavaa 90 astetta ja takaisin
void kippaa() {
	playTone(700, 100);
	eteen(0);
	
	setMotorTarget(motorA, -85, 20);
	//waitUntilMotorStop(motorA);

	wait1Msec(2000);

	setMotorTarget(motorA, 90, 20);
	//waitUntilMotorStop(motorA);
	
	wait1Msec(2000);
}

/*
Alitehtavan toteutus
Funktio toteuttaa liikkumisen tavan ja triggerit

int liikenopeus		täysillä : 0
									hidasta  : 1
									kiihdyta : 2
									pysahdy  : 3
									hidas    : 4
									
int suunta				eteen    : 0
									kaanna   : 1
									paikoill : 2
									taakse   : 3
									
int anturi				eimikaan : 0
									gyro     : 1
									infra    : 2
									kosketus : 3
*/
void toteutaAliTehtava(int liikenopeus, int suunta, int anturi, short kulma) {

	// Lue uusin vari
	// Colours range from 0 to 7
  // None    = 0
  // Black   = 1
  // Blue    = 2
  // Green   = 3
  // Yellow  = 4
  // Red     = 5
  // White   = 6
  // Brown   = 7
	currentColour = SensorValue[variluotain];
	
	switch(currentColour) {
		case 3 :
			// TODO Roskilla
			subtask = 8;
			return;
			break;
		default :
			// Ei tehda mitaan
			break;
	}

	displayCenteredBigTextLine(8, "liikenopeus: %d", liikenopeus);
	displayCenteredBigTextLine(10, "suunta: %d", suunta);
	displayCenteredBigTextLine(12, "anturi: %d", anturi);
	displayCenteredBigTextLine(14, "kulma: %d", kulma);

	switch(anturi) {
		case 0 :
			// ei mitaan
			break;
		case 1 :
			// gyro
			if (SensorValue(Gyroskooppi) > kulma-10 && SensorValue(Gyroskooppi) < kulma+10) {
				subtask += 1;
				return;
			}
			break;
		case 2 :
			// infra
			if (getIRDistance(etaluotain) < 20) {
				subtask += 1;
				return;
			}
			break;
		case 3 :
			// Kosketus
			if (SensorValue[kosketus]) {
				subtask = 3;
				return;
			}
			break;
	}

	switch(liikenopeus) {
		case 0 :
			// täysillä
			nopeus = 100;
			break;
		case 1 :
			// hidasta
			if (nopeus == 0) {
				subtask += 1;
				return;
			}
			nopeus -= 10;
			break;
		case 2 :
			// kiihdyta
			if (nopeus == 100) {
				subtask += 1;
				return;
			}
			nopeus += 10;
			break;
		case 3 :
			// Pysahdy
			nopeus = 0;
			break;
		case 4 :
			// hidas
			nopeus = 30;
			break;
	}

	switch(suunta) {
		case 0 :
			// eteen
			eteenGyrolla(kulma);
			break;
		case 1 :
			// kaanna
			kaannyGyrolla(kulma);
			break;
		case 2 :
			// Paikoillaan
			eteen(0);
			break;
		case 3 :
			// taakse
			taakse(nopeus);
			break;
	}
}

/*
Tehtavan toteutus

alitehtavien jarjestys.
*/
void toteutaTehtava(short kulma) {

	switch(subtask) {
		case 0 :
			//int liikenopeus, int suunta, int anturi, short kulma
			// hidasta eteen eiAnturi
			toteutaAliTehtava(1, 0, 0, kulma);
			break;
		case 1 :
			// kaanna kiihdyta gyro
			toteutaAliTehtava(2, 1, 1, kulma);
			break;
		case 2 :
			// hidasta kaanna gyro
			toteutaAliTehtava(1, 1, 1, kulma);
			break;
		case 3 :
			// hitaasti kaanna gyro
			toteutaAliTehtava(4, 1, 1, kulma);
			break;
		case 4 :
			// kiihdyta eteen infra 
			toteutaAliTehtava(2, 0, 2, kulma);
			break;
		case 5 :
			// taysilla eteen infra
			toteutaAliTehtava(0, 0, 2, kulma);
			break;
		case 6 :
			// vaihda maintask
			subtask = 0;
			maintask += 1;
			break;
		case 7 :
			// Odota
			// pysahdy paikallaan kosketus
			setLEDColor(ledOrange);
			toteutaAliTehtava(3, 2, 3, kulma);
			break;
		case 8 :
			// hidasta eteen eiAnturi
			toteutaAliTehtava(1, 0, 0, kulma);
			break;
		case 9 :
			// kiihdyta taakse eiAnturi
			toteutaAliTehtava(2, 3, 0, kulma);
			break;
		case 10 :
			// hidasta taakse eiAnturi
			toteutaAliTehtava(1, 3, 0, kulma);
			break;
		case 11 :
			// 180 astetta ympari
			// hitaasti kaanna gyro
			toteutaAliTehtava(4, 1, 1, kulma+180);
			break;
		case 12 :
			// kippaa
			kippaa();
			subtask = 7;
			break;
	}
}

task main() {

	// Nollataan gyro robotin menosuunnan mukaiseksi
	setSensorMode(Gyroskooppi, modeEV3Gyro_Angle);
	resetGyro(Gyroskooppi);

	// Asetataan kone tyojarj. sisaan
	// Paatehtava 0, eli alusta
	maintask = 0;
	// alitehtava 7, eli odotus
	subtask = 7;
	// Nopeus 0, eli paikoillaan
	nopeus = 0;

	while (true) {

		displayCenteredBigTextLine(1, "main: %d", maintask);
		displayCenteredBigTextLine(3, "sub: %d", subtask);
		displayCenteredBigTextLine(6, "angle: %d", SensorValue(Gyroskooppi));

		// Paatehtavien jarjestys
		switch(maintask) {
			case 0 :
				// kohti
				toteutaTehtava(0);
				break;
			case 1 :
				// vasen
				toteutaTehtava(-90);
				break;
			case 2 :
				// kohti
				toteutaTehtava(0);
				break;
			case 3 :
				// oikea
				toteutaTehtava(90);
				break;
		}

		if (maintask > 3) {
			maintask = 0;
		}
	}
}
